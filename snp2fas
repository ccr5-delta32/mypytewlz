#!/usr/bin/python

''' Bjorn Pieper, June 2016, MPIPZ Cologne.
    FASTA alignment of SNPs for arbitrary regions.
'''

from subprocess import call
from sys import exit, argv
from argparse import ArgumentParser
from uuid import uuid4

p = ArgumentParser(prog='snp2fas', description='Produce FASTA alignments'+\
                   ' for arbitrary regions and sets of accessions')
p.add_argument('-snp', metavar='<String>', help='Path to SNP table',
               required=True)
p.add_argument('-t', metavar='<Int>', help='5\' position. Omit to '+\
               'start at 1st SNP.', required=False)
p.add_argument('-b', metavar='<Int>', help='3\' position. Omit to '+\
               'include until last SNP.', required=False)
p.add_argument('-o', metavar='<String>', help='Output file name, if '+\
               'omitted the file name will be the SNP table name extended'+\
               ' with \'.fa\'. Take care that this may not be unique in your'+\
               ' path!', required=False)
p.add_argument('-f', help='Convert ambiguous base calls '+\
               'to \'N\'. Default is no filtering.', required=False, 
               action='store_true')
p.add_argument('-F', help='Exclude sites with any ambiguous '+\
               'base calls or \'N\'.', required=False, action='store_true') 
p.add_argument('-m', help='Include sites that are monomorphic in the '+\
               'ingroup', required=False, action='store_true')
p.add_argument('-i', metavar='<String>', help='Path to list of accessions to '+\
               'include. When -i is given the argument \'makelist\' it will '+\
               'produce a file with the header of the SNP table, which can be'+\
               ' useful to produce the list. When omitted all accessions '+\
               'in the SNP table are included.', required=False)
p.add_argument('-out', metavar='<String>', help='Indicate the outgroup in '+\
               'the SNP table in case you want it included in the fasta '+\
               'alignment when selecting only a subset of accessions from '+\
               'the SNP table', required=False)

if len(argv) == 1:
    p.print_help()
    exit(0)

args = p.parse_args()

if args.i:
    with open(args.snp, 'r') as IN:
        header = IN.readline().strip('\n').split('\t')
    if args.i == 'makelist':
        with open(args.snp.split('/')[-1] + '.list', 'w') as OUT:
            for i in header: 
                OUT.write(i + '\n')
        print 'A list of accessions included in ' +\
        args.snp.split('/')[-1] + ' has been written to '+\
        args.snp.split('/')[-1] + '.list'       
        exit(0)
    else:
        inc_indx = [header.index(i) for i in\
                    open(args.i).read().split('\n')[:-1]]

if args.t or args.b: 
    composite1 = '$2>=' + str([args.t, 1][args.t is None]) +\
                 ' && $2<=' + str([args.b, 9999999999][args.b is None])
    tmp = str(id(composite1)) + '.DeleteMe'
    with open(tmp, 'w') as outfile:
        call(['awk', composite1, args.snp], stdout=outfile)
        snps = [i.split('\t') for i in open(tmp).read().split('\n')][:-1]
    call([ 'rm', tmp ])
else:
    snps = [i.split('\t') for i in open(args.snp).read().split('\n')][1:-1]
    if not inc_indx:
        inc_indx = range(2,len(snps[0])-1)

fasta = [[] for i in inc_indx]
positions = []
if args.out: 
    outgroup = []
    out_indx = header.index(args.out)
nucl = ['A', 'G', 'C', 'T']

for snp in snps:
    
    if not args.m and len(set([snp[i] for i in inc_indx])) == 1: continue

    if args.F:
        if True in [snp[i] not in nucl for i in inc_indx]: continue
    if args.f:
        for indx, value in enumerate([snp[i] for i in inc_indx]):
            if value not in nucl:
                snp[indx] = 'N'

    positions.append(snp[1])
    [fasta[i].append(snp[inc_indx[i]]) for i in range(len(inc_indx))]

    if args.out:
        outgroup.append(snp[out_indx])

if not args.o:
    vOUTPUT = args.snp.split('/')[-1]  
else:
    vOUPUT = args.o

if len(fasta[0]) == 0:
    exit('No sites passed filtering!')

print 'Writing ' + str(len(fasta[0])) + ' sites to fasta alignment'

with open(vOUTPUT + '.pos', 'wb') as output:
    for pos in positions:
        output.write(str(pos) + '\n')

with open(vOUTPUT + '.fa', 'wb') as output:
    for i in range(len(inc_indx)):
        output.write('>' + header[inc_indx[i]] + '\n')
        output.write(''.join(fasta[i]) + '\n')
        if args.out:
            output.write('>' + header[out_indx] + '\n')
            output.write(''.join(outgroup))
